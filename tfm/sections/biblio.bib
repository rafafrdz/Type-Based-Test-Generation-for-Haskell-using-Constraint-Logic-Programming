@inproceedings{pbtfree,
	title        = {Property-Based Test Case Generators for Free},
	author       = {De Angelis, Emanuele and Fioravanti, Fabio and Palacios, Adri{\'a}n and Pettorossi, Alberto and Proietti, Maurizio},
	year         = 2019,
	booktitle    = {Tests and Proofs},
	publisher    = {Springer International Publishing},
	address      = {Cham},
	pages        = {186--206},
	isbn         = {978-3-030-31157-5},
	editor       = {Beyer, Dirk and Keller, Chantal},
	abstract     = {Property-Based Testing requires the programmer to write suitable generators, i.e., programs that generate (possibly in a random way) input values for which the program under test should be run. However, the process of writing generators is quite a costly, error-prone activity. In the context of Property-Based Testing of Erlang programs, we propose an approach to relieve the programmer from the task of writing generators. Our approach allows the automatic, efficient generation of input test values that satisfy a given specification. In particular, we have considered the case when the input values are data structures satisfying complex constraints. That generation is performed via the symbolic execution of the specification using constraint logic programming.}
}
@article{rbtreehaskell,
	title        = {Red-black trees in a functional setting},
	author       = {Okasaki, Chris},
	year         = 1999,
	journal      = {Journal of Functional Programming},
	publisher    = {Cambridge University Press},
	volume       = 9,
	number       = 4,
	pages        = {471–477},
	doi          = {10.1017/S0956796899003494}
}
@book{cpierce,
	title        = {Types and Programming Languages},
	author       = {Pierce, Benjamin C.},
	year         = 2002,
	publisher    = {The MIT Press},
	isbn         = {0262162091},
	edition      = {1st},
	abstract     = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}
@inproceedings{quickcheck,
	title        = {QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs},
	author       = {Claessen, Koen and Hughes, John},
	year         = 2000,
	booktitle    = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {ICFP '00},
	pages        = {268–279},
	doi          = {10.1145/351240.351266},
	isbn         = 1581132026,
	url          = {https://doi.org/10.1145/351240.351266},
	abstract     = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
	numpages     = 12
}
@inproceedings{genclp,
	title        = {Generation of Test Data Structures Using Constraint Logic Programming},
	author       = {Senni, Valerio and Fioravanti, Fabio},
	year         = 2012,
	month        = {05},
	volume       = 7305,
	pages        = {115--131},
	doi          = {10.1007/978-3-642-30473-6_10},
	isbn         = {978-3-642-30472-9}
}
@article{effgenttransf,
	title        = {Efficient Generation of Test Data Structures using Constraint Logic Programming and Program Transformation},
	author       = {Fioravanti, Fabio and Proietti, Maurizio and Senni, Valerio},
	year         = 2013,
	month        = 11,
	journal      = {Journal of Logic and Computation},
	doi          = {10.1093/logcom/ext071}
}
@inbook{smtbased,
	title        = {SMT-Based Test-Case Generation and Validation for Programs with Complex Specifications},
	author       = {Peña, Ricardo and Sánchez-Hernández, Jaime and Garrido, Miguel and Sagredo, Javier},
	year         = 2023,
	month        = {05},
	pages        = {188--205},
	doi          = {10.1007/978-3-031-31476-6_10},
	isbn         = {978-3-031-31475-9}
}
@misc{hasksynt,
	title        = {Haskell 98. Syntax},
	howpublished = {\url{https://www.haskell.org/onlinereport/syntax-iso.html}}
}
@misc{haskdat,
	title        = {Haskell 98. User-Defined Datatypes},
	howpublished = {\url{https://www.haskell.org/onlinereport/decls.html}}
}
@misc{qcrepo,
	title        = {QuickCheck. Github Reposittory},
	howpublished = {\url{https://github.com/nick8325/quickcheck}}
}
@misc{screpo,
	title        = {ScalaCheck. Github Reposittory},
	howpublished = {\url{https://github.com/typelevel/scalacheck}}
}
@misc{pprepo,
	title        = {PropEr. Github Reposittory},
	howpublished = {\url{https://github.com/proper-testing/proper}}
}
@misc{hprepo,
	title        = {Hypothesis. Github Reposittory},
	howpublished = {\url{https://github.com/HypothesisWorks/hypothesis}}
}
@article{pbtnewapproach,
	title        = {Property-Based Testing: A New Approach to Testing for Assurance},
	author       = {Fink, George and Bishop, Matt},
	year         = 1997,
	month        = {jul},
	journal      = {SIGSOFT Softw. Eng. Notes},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 22,
	number       = 4,
	pages        = {74–80},
	doi          = {10.1145/263244.263267},
	issn         = {0163-5948},
	url          = {https://doi.org/10.1145/263244.263267},
	issue_date   = {July 1997},
	abstract     = {The goal of software testing analysis is to validate that an implementation satisfies its specifications. Many errors in software are caused by generalizable flaws in the source code. Property-based testing assures that a given program is free of specified generic flaws. Property-based testing uses property specifications and a data-flow analysis of the program to guide evaluation of test executions for correctness and completeness.},
	numpages     = 7
}
@inproceedings{arttesting,
	title        = {The Art of Testing Less without Sacrificing Quality},
	author       = {Herzig, Kim and Greiler, Michaela and Czerwonka, Jacek and Murphy, Brendan},
	year         = 2015,
	booktitle    = {Proceedings of the 37th International Conference on Software Engineering - Volume 1},
	location     = {Florence, Italy},
	publisher    = {IEEE Press},
	series       = {ICSE '15},
	pages        = {483–493},
	isbn         = 9781479919345,
	abstract     = {Testing is a key element of software development processes for the management and assessment of product quality. In most development environments, the software engineers are responsible for ensuring the functional correctness of code. However, for large complex software products, there is an additional need to check that changes do not negatively impact other parts of the software and they comply with system constraints such as backward compatibility, performance, security etc. Ensuring these system constraints may require complex verification infrastructure and test procedures. Although such tests are time consuming and expensive and rarely find defects they act as an insurance process to ensure the software is compliant. However, long lasting tests increasingly conflict with strategic aims to shorten release cycles. To decrease production costs and to improve development agility, we created a generic test selection strategy called THEO that accelerates test processes without sacrificing product quality. THEO is based on a cost model, which dynamically skips tests when the expected cost of running the test exceeds the expected cost of removing it. We replayed past development periods of three major Microsoft products resulting in a reduction of 50\% of test executions, saving millions of dollars per year, while maintaining product quality.},
	numpages     = 11,
	keywords     = {measurement, cost estimation, test improvement}
}
@article{tddpaper,
	title        = {Test-driven development concepts, taxonomy, and future direction},
	author       = {Janzen, D. and Saiedian, H.},
	year         = 2005,
	month        = {Sep.},
	journal      = {Computer},
	volume       = 38,
	number       = 9,
	pages        = {43--50},
	doi          = {10.1109/MC.2005.314},
	issn         = {1558-0814},
	abstract     = {Test-driven development creates software in very short iterations with minimal upfront design. This strategy requires writing automated tests prior to developing functional code in small, rapid iterations. Although developers have been applying TDD in various forms for several decades, this software development strategy has continued to gain increased attention as one of the core extreme programming practices.}
}
@inproceedings{correctnesspaper,
	title        = {Tutorial: The Correctness-by-Construction Approach to Programming Using CorC},
	author       = {Schaefer, Ina and Runge, Tobias and Cleophas, Loek and Watson, Bruce W.},
	year         = 2021,
	month        = {Oct},
	booktitle    = {2021 IEEE Secure Development Conference (SecDev)},
	pages        = {1--2},
	doi          = {10.1109/SecDev51306.2021.00012},
	abstract     = {The Correctness-by-Construction tutorial focuses on a structured programming approach for correct software development. Besides functional correctness, also non-functional properties such as security properties can be guaranteed using the CbC approach. In this tutorial, the participants learn a good practice to develop software that is midway between formal approaches and a “hack into correctness” style.}
}
@inproceedings{efftdd,
	title        = {Effects of Test-Driven Development: A Comparative Analysis of Empirical Studies},
	author       = {Makinen, Simo and Münch, Jürgen},
	year         = 2014,
	month        = {01},
	journal      = {Lecture Notes in Business Information Processing},
	volume       = 166,
	doi          = {10.1007/978-3-319-03602-1_10},
	isbn         = {978-3-319-03601-4}
}
@article{strtyped,
	title        = {Strong Typing vs. Strong Testing},
	author       = {Eckel, Bruce},
	year         = 2005,
	month        = {01},
	doi          = {10.1007/978-1-4302-0038-3_11},
	isbn         = {978-1-59059-500-8}
}
@inproceedings{stvsdt,
	title        = {Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages},
	author       = {Meijer, Erik and Drayton, Peter},
	year         = 2004,
	month        = {01}
}
@misc{scheckart,
	title        = {Typelevel | Let's build ourselves a small ScalaCheck},
	author       = {Lars Hupel},
	howpublished = {\url{https://typelevel.org/blog/2016/10/17/minicheck.html}}
}
