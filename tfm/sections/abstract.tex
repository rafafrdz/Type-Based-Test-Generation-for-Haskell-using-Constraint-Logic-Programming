\chapter*{Resumen}

Construir \textit{generadores} para crear casos de prueba es uno de los puntos importantes para poder disponer de herramientas de testing automático. Una de las técnicas más conocidas, Property-Based Testing (PBT) utiliza este sistema para probar el comportamiento del software. Sin embargo la generación de estos valores es una tarea difícil, bastante costosa y propensa a errores. Aunque la mayoría de los marcos de PBT cubren escenarios simples, suele haber problemas con los casos de prueba generados puesto que existen algunas que requieren ciertas propiedades de los datos de entrada y que a menudo estas propiedades tienen que ver con precondiciones de funciones del SW que se se está probando.
\\\\
%%
En el contexto de las PBT para lenguajes fuertes y estáticamente bien tipados, como Haskell o Scala, proponemos un enfoque para aliviar al programador de la tarea de escribir estos generadores.\\\\
%%
Nuestro enfoque proporciona una generación eficiente y automática de valores como \textit{inputs} siguiendo la gramática formal de Haskell, concretamente, un mecanismo de traducción sintáctica guiado por la declaración de tipos. Esta es una característica que la mayoría de las herramientas conocidas de PBT como QuickCheck, por ejemplo, aún no tienen implementada. En particular, consideramos el caso en que los valores de entrada son tipos de datos algebraicos.\\\\
%%
El proceso de generación se realiza a través de las especificaciones de las expresiones definidas según sintaxis del lenguaje y mediante resolución simbólica en lenguajes de programación lógica de restricciones. Puesto que los lenguajes de programación funcional modernos admiten declaraciones de tipos definidos por el usuario de una cierta complejidad -- e.g. tipos paramétricos o polimórficos -- haremos una presentación incremental de nuestra función de traducción. En una primera fase trataremos solo aquellas declaraciones no paramétricas o monomórficas. En este escenario, los tipos de datos algebraicos no se definen mediante una representación polimórfica en su declaración, siendo este el caso más sencillo de abarcar. Después, cubriremos la versión polimórfica de nuestra función de traducción sintáctica, añadiendo la complejidad de la parametrización de los tipos en la definición del ADT. Además, debido a que los lenguajes CLP tratan de proporcionar un espacio generado infinito de solución, en este trabajo, proporcionamos algunas técnicas para limitarlo y obtener un espacio de valores generados suficientemente bueno que mantenga la completitud que necesitamos en nuestros casos de prueba. Definimos aquí un concepto de \textit{tamaño} alrededor y en estrecha relación al significado de completitud que buscamos, e integramos ese concepto en la definición de nuestra función.\\\\
%%
Por último, hablamos de aquellos enfoques interesantes que serían adecuados para el trabajo futuro. Por ejemplo, haciendo extensiones de sintaxis Haskell utilizando Liquid Haskell para proporcionar invariantes o restricciones complejas en el proceso de generación. Con esta nueva característica, podríamos cubrir tipos de datos algebraicos como pueden ser estructuras de arbol rojo y negro.

\begin{otherlanguage}{english}
	\chapter*{Abstract}
	Building generators to create test cases is one of the important points to be able to have automatic testing tools. One of the best known techniques, Property-Based Testing (PBT) uses this system to test software behavior. However, the generation of these values is a difficult, rather costly and error-prone task. Although most PBT frameworks cover simple scenarios, there are often problems with the generated test cases since there are some that require certain properties of the input data and often these properties have to do with preconditions of functions of the SW being tested.
	\\\\
	%%
	In the context of PBTs for strong and statically well-typed languages, such as Haskell or Scala, we propose an approach to relieve the programmer from the task of writing these generators.\\\\
	%%
	Our approach provides efficient and automatic generation of values such as \textit{inputs} following Haskell's formal grammar, namely, a syntactic translation mechanism guided by type declaration. This is a feature that most known PBT tools such as QuickCheck, for example, do not yet have implemented. In particular, we consider the case where the input values are algebraic data types.\\\\
	%%
	The generation process is performed through the specification of expressions defined according to language syntax and by symbolic resolution in constraint logic programming languages. Since modern functional programming languages support user-defined type declarations of a certain complexity -- e.g. parametric or polymorphic types -- we will make an incremental presentation of our translation function. In a first phase we will treat only those non-parametric or monomorphic declarations. In this scenario, algebraic data types are not defined by a polymorphic representation in their declaration, this being the simplest case to cover. Next, we will cover the polymorphic version of our syntactic translation function, adding the complexity of type parameterization in the ADT definition. Also, because CLP languages try to provide an infinite generated space of solution, in this paper, we provide some techniques to limit it and obtain a good enough generated value space that maintains the completeness we need in our test cases. We define here a concept of Ôtextit{size} around and closely related to the meaning of completeness we seek, and integrate that concept into our function definition.
	%%
	Finally, we discussed those interesting approaches that would be suitable for future work. For example, making Haskell syntax extensions using Liquid Haskell to provide invariants or complex constraints in the generation process. With this new feature, we could cover algebraic data types such as red and black tree structures.
		
\end{otherlanguage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Final del resumen.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
